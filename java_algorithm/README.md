# java_algorithm

* 프로파일링 : 어떤 응용 프로그램에 어느 클래스가 더 좋을지 확인하기 위해 두 클래스 모두다 시도해 보고 각각 얼마나 걸리는지 알아본다.
* 문제점
	* 알고리즘을 비교하려면 사전에 그것을 모두 구현해봐야 한다.
	* 사용하는 컴퓨터의 성능에 따라 결과가 달라질수 있다.(한 알고리즘이 어떤 컴퓨터에서는 더 좋을 수 있지만, 다른 컴퓨터에서 더 좋을 수도 있다.)
	* 문제 크기나 입력으로 사용하는 데이터에 따라 결과가 달라질수 있다.
	
* 알고리즘 분석을 이용한다면 클래스 구현 없이 성능을 비교할수 있다.
* 알고리즘 분석을 사용하기 위한 가정
	* 컴퓨터 하드웨어의 세부사항을 다루지 않기 위해 보통 알고리즘을 이루는 더하기와 곱하기, 숫자 비교 등의 기본 연산을 식별함. 그리고 각 알고리즘에 필요한 연산 수를 센다.
	* 입력 데이터의 세부사항을 다루지 않으려면 가장 좋은 선택은 기대하는 입력 데이터에 대한 평균 성능을 분석하는 것, 이것이 가능하지 않을 때는 일반적인 대안으로 최악의 시나리오는 분석함
	* 한 알고리즘이 작은 문제에서는 회상의 성능을 보이지만 큰 문제에서는 다른 알고리즘이 더 좋을 수 있다는 가능성을 배제하면 안된다. 이때는 보통 큰 문제에 초점을 맞춤.( 작은 문제에서는 알고리즘이 차이가 크지 않지만, 큰문제에서는 그 차이가 거대해질 수 있다.)
	

* 상수 시간
	* 실행시간이 입력 크기에 의존하지 않으면 알고리즘은 상수 시간을 따른다.
	* 예를 들어, n개의 배열에서 브래킷 연산([])을 사용하여 요소 중 하나에 접근할 때 이 연산은 배열의 크기와 관계없이 같은 수의 동작을 수행한다.
* 선형
	* 실행시간이 입력 크기에 비례하면 알고리즘은 선형이라고 한다.
	* 예를 들어, 배열에 있는 요소를 더한다면 n개의 요소에 접근하여 n-1번 더하기 연산을 해야한다. 연산(요소 접근과 더하기)의 총 횟수는 2n-1이고 n에 비례합니다.
* 이차
	* 실행시간이 n^2에 비례하면 알고리즘은 이차라고 합니다.
	* 예를 들어, 리스트에 있는 어떤 요소가 두 번 이상 나타나는지를 알고 싶다고 가정한다면, 간단한 알고리즘은 각 요소를 다른 모든 요소와 비교한다.
	* n개의 요소가 있고 각 n-1개의 다른 요소와 비교하면 총 비교 횟수는 n^2-n이 되어 n이 커지면서 n^2에 비례한다.
  
# MyArrayList와 MyLinkedList 비교

| 구분 | MyArrayList | MyLinkedList | LinkedList |
| --- | --- | --- | --- |
| add(end) | 1 | n | 1 | 
| add(start) | n | 1 | 1 |
| add(commonly) | n | n | n |
| get/set | 1 | n | n |
| indexOf/lastIndexOf | n | n | n |
| isEmpty/size | 1 | 1 | 1 |
| remove(end) | 1 | n | 1 |
| remove(start) | n | 1 | 1 | 
| remove(commonly) | n | n | n |

* 응용프로그램의 실행시간이 get과 set 메서드에 의존한다면 ArrayList 클래스가 더 좋다.
* 실행시간이 시작이나 끝 근처에 요소를 추가하거나 제거하는 연산에 의존한다면 LinkedList 클래스가 좋다.

* 위 추전은 큰 문제의 증가 차수에 기반을 두고 있습니다. 이 외에 고려해야 할 요소는 다음과 같습니다.
    * 이러한 연산이 응용 프로그램의 실행 시간에 뚜렷한 영향을 미치지 않는다면, 즉 응용 프로그램이 다른 일을 하느라 대부분 시간을 소모하면 List 구현에 대한 선택을 큰의미가 없다.
    * 작업하는 리스트가 매우 크지 않으면 기대하는 성능을 얻기 어려울수도 있다.
    작은 문제에서는 이차 알고리즘이 선형 알고리즘보다 빠르기도 하고 또는 선형 알고리즘이 상수 시간보다 빠르기도 하다. -> 작은 문제에서는 그 차이가 그리 중요하지 않다.
    * ArrayList에서 요소들은 한 덩어리의 메모리 안에 나란히 저장되어 거의 낭비하는 공간이 없고, 컴퓨터 하드웨어도 연속된 덩어리에서 종종 속도가 빠르다.
    연결 리스트에서 각 요소는 하나 또는 두 개의 참조가 있는 노드가 필요하다.
    참조는 공간을 차지한다.(때로는 데이터보다 클 수도 있음).
    메모리 여기저기에 노드가 흩어져 있으면 하드웨어의 효율이 떨어질 수 있다.
    
# 검색 엔진

* 검색 엔진의 필수 요소
    * 크롤링 (crawing) : 웹 페이지를 다운로드하고 파싱하고 텍스트와 다른 페이지로의 링크를 추출하는 프로그램
    * 인덱싱 (indexing) : 검색어를 조회하고 해당 검색어를 포함한 페이지를 찾는 데 필요한 자료구조
    * 검색 (retrieval) : 인덱스에서 결과를 수집하고 검색어와 가장 관련된 페이지를 식별하는 방법
 


# 참고
  
* http://www.yes24.com/Product/Goods/61198657?scode=032&OzSrank=4  자바로 배우는 핵심 자료구조와 알고리즘
